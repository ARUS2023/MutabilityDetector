#summary Current state of play regarding the analysis performed by Mutability Detector
#labels Phase-Design,Phase-Requirements,Phase-Implementation

= Introduction =
Mutability Detector is not perfect in it's analysis, this page will discuss some of the limitations of the analysis. For each of the patterns listed below, Mutability Detector cannot correctly detect them.


== Field can be reassigned after construction (SetterMethodChecker) ==
=== Benign Data Races ===

A benign data race is when there is the potential for a data race, but however the data is read and written, the effects are harmless. A simple example could be:

{{{
public int benign() {
    if(this.field == 0) {
        this.field = 42;
    }
    return this.field;
}
}}}

Here there is the potential for a data race between threads calling `benign()`, but no matter how the threads call the method, the result is always going to be 42. (Note this is not necessarily the case for `long` or `double` fields, where reassignment is not atomic). A rough rule of thumb is that if the value is calculated from immutable state, it's a benign data race.

This kind of pattern allows lazy calculation of fields. A prominent example is `java.lang.String.hashCode()` with the `hash` field. 

This is currently the only reason `String` is considered mutable.

== Reference to 'this' can escape during construction ==

JCIP warns of the danger of letting the 'this' reference escape, as clients may see the object change between that point and when the constructor completes. There's more discussion of this issue [http://mutability-detector.blogspot.com/2010/07/escapedthisreferencechecker-sketch-of.html in this blog entry]. Beyond made up test cases for this problem, there's basically been no work done on this. I've so far hit a bit of a wall where control and data flow analysis will need to get more complicated to support this.